(function(window, undefined) {'use strict';

var urlBase = <%-: urlBase | q %>;
var authHeader = 'authorization';

var <%-: resourceName %> = {};

<% for (var modelName in models) {
     var meta = models[modelName];

     // capitalize the model name
     modelName = modelName[0].toUpperCase() + modelName.slice(1);
-%>
    <%-: resourceName %>.<%-: modelName %> = Vue.resource(
      urlBase + <%-: meta.ctor.getFullPath() | q %>,
<% /*
        Constructor arguments are hardcoded for now.
        We should generate it from sharedCtor.accepts instead.
*/ -%>
      { 'id': '@id' },
      {
<% meta.methods.forEach(function(action) {
     var methodName = action.name.split('.').join('$');
-%>
        <%-: methodName | q %>: {
<% if (action.isReturningArray()) { -%>
          isArray: true,
<% } -%>
<% if (meta.isUser && methodName === 'login') { -%>
          params: {
            include: "user"
          },
          interceptors: {
            'afterLogin': {
              response: function(response) {
                var accessToken = response.data;
                <%-: resourceName %>.LoopBackAuth.setUser(accessToken.id, accessToken.userId, accessToken.user);
                // <%-: resourceName %>.LoopBackAuth.rememberMe = response.config.params.rememberMe !== false;
                <%-: resourceName %>.LoopBackAuth.save();
                return response.resource;
              }
            }
          },
<% } else if (meta.isUser && methodName === 'logout') { -%>
          interceptors: {
            'afterLogout': {
              response: function(response) {
                <%-: resourceName %>.LoopBackAuth.clearUser();
                <%-: resourceName %>.LoopBackAuth.clearStorage();
                return response.resource;
              }
            }
          },
<% } -%>
<% if (action.hasResourceParams) { -%>
          params: {
<%   action.resourceParams.forEach(function(param, i, arr) { -%>
          '<%= param.arg %>': '@<%= param.arg %>'<%= i < arr.length -1 ? ',' : '' %>
<%   }); //action.params.foreach -%>
          },
<% } -%>
          url: urlBase + <%-: action.getFullPath() | q %>,
          method: <%-: action.getHttpMethod() | q %>
        },
<% }); // meta.methods.foreach -%>
<% if (meta.isUser) { -%>

        "getCurrent": {
           url: urlBase + <%-: meta.getPath() | q %> + "/:id",
           method: "GET",
           params: {
             id: function() {
              var id = <%-: resourceName %>.LoopBackAuth.currentUserId;
              if (id == null) id = '__anonymous__';
              return id;
            },
          },
          interceptors: {
            'afterGetCurrent': {
              response: function(response) {
                <%-: resourceName %>.LoopBackAuth.currentUserData = response.data;
                return response.resource;
              }
            }
          },
          __isGetCurrentUser__ : true
        }
<% } -%>
      },
      {
        interceptors: {
            'afterResponse': {
                response: function(response) {
                  console.log('after response')
                  return response;
                }
            }
        }
      }
    );


<% meta.methods.forEach(function(action) {
    var methodName = action.name.split('.').join('$');
    (action.sharedMethod.aliases || []).forEach(function(alias) {
      var aliasMethod = alias.split('.').join('$');
-%>
        <%-: resourceName %>.<%-: modelName %>[<%-: aliasMethod | q %>] = <%-: resourceName %>.<%-: modelName %>[<%-: methodName | q %>];
<%  }); // aliases.foreach
  }); // meta.methods.foreach
-%>

<% if (meta.isUser) { -%>
        <%-: resourceName %>.<%-: modelName %>.getCachedCurrent = function() {
          var data = <%-: resourceName %>.LoopBackAuth.currentUserData;
          return data ? new <%-: resourceName %>.<%-: modelName %>(data) : null;
        };

        <%-: resourceName %>.<%-: modelName %>.isAuthenticated = function() {
          return this.getCurrentId() != null;
        };

        <%-: resourceName %>.<%-: modelName %>.getCurrentId = function() {
          return <%-: resourceName %>.LoopBackAuth.currentUserId;
        };
<% } -%>

    <%-: resourceName %>.<%-: modelName %>.modelName = <%-: modelName | q %>;

<% for (var scopeName in meta.scopes) {
      var scope = meta.scopes[scopeName];
      if (!scope) continue;
      var scopeMethods = scope.methods;
      // Angular names always start with a capital letter
      var targetClass = scope.targetClass[0].toUpperCase() + scope.targetClass.slice(1);

      if (Object.keys(scopeMethods).length > 1) {
-%>

<%
      }

      // sort the names to make sure the get method creating the scope
      // is emitted first (R.categories before R.categories.create)
      Object.keys(scopeMethods).sort().forEach(function(methodName) {
        var action = scopeMethods[methodName];

        // modelName is e.g. 'User'
        // methodName is e.g. 'accessTokens.create'
        // we need to convert it to 'User.accessTokens' and 'create'
        var names = methodName.split('.');
        var ngMethod = names.pop();
        var ngClass = [modelName].concat(names).join('.');

-%>
        <%-: resourceName %>.<%-: modelName %>.<%- methodName %> = function() {
          // var TargetResource = $injector.get(<%-: targetClass | q %>);
          // var action = TargetResource[<%-: action.name | q %>];
          var action = <%-: resourceName %>.<%-: targetClass %>[<%-: action.name | q %>]
          return action.apply(<%-: resourceName %>.<%-: modelName %>, arguments);
        };
<%    }); // forEach methods name -%>
<% } // for each scope -%>


<% } // for modelName in models -%>


var LoopBackAuth = function() {
    this.props = ['accessTokenId', 'currentUserId', 'currentUserData'];
    this.propsPrefix = '$LoopBack$';
    this.rememberMe = undefined;
    this.currentUserData = null;

    this.loadStorage();
}

LoopBackAuth.prototype.loadStorage = function(name) {
  var self = this;
  this.props.forEach(function(name) {
      var key = self.propsPrefix + name;
      // update to store only JSON
      self[name] = 
        ( localStorage[key] !== null && localStorage[key] !== undefined && localStorage[key] !== '' ? JSON.parse(localStorage[key]) : null ) || 
        ( sessionStorage[key] !== null && sessionStorage[key] !== undefined && sessionStorage[key] !== '' ? JSON.parse(sessionStorage[key]) : null ) || 
        null;
  });
}

// Note: LocalStorage converts the value to string
// We are using empty string as a marker for null/undefined values.
LoopBackAuth.prototype.saveStorage = function(storage, name, value) {
  var key = this.propsPrefix + name;
  if (value == null) value = '';
  // update to store only JSON
  storage[key] = JSON.stringify(value);
}

LoopBackAuth.prototype.save = function() {
  var self = this;
  var storage = this.rememberMe ? localStorage : sessionStorage;
  this.props.forEach(function(name) {
    self.saveStorage(storage, name, self[name]);
  });
};

LoopBackAuth.prototype.setUser = function(accessTokenId, userId, userData) {
  this.accessTokenId = accessTokenId;
  this.currentUserId = userId;
  this.currentUserData = userData;
}

LoopBackAuth.prototype.clearUser = function() {
  this.accessTokenId = null;
  this.currentUserId = null;
  this.currentUserData = null;
}

LoopBackAuth.prototype.clearStorage = function() {
  var self = this;
  this.props.forEach(function(name) {
    self.saveStorage(sessionStorage, name, null);
    self.saveStorage(localStorage, name, null);
  });
};

<%-: resourceName %>.LoopBackAuth = new LoopBackAuth();


window.<%-: resourceName %> = <%-: resourceName %>;

// Add JWT for API with an interceptor
Vue.http.interceptors.push({

    request: function(request) {
        // filter out non urlBase requests
        if (request.url.substr(0, urlBase.length) === urlBase
            && <%-: resourceName %>.LoopBackAuth.accessTokenId !== null) {
            request.headers[authHeader] = <%-: resourceName %>.LoopBackAuth.accessTokenId;
        } 
        return request;
    }
})

})(window);
